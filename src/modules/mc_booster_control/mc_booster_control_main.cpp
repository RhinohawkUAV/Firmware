/****************************************************************************
 *   Copyright (c) 2013-2015 PX4 Development Team. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name PX4 nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ****************************************************************************/

 /**************************************************************************
  * @file booster_control_main
  * Multirotor Booster Motor Controller
  *
  * Copyright (c) 2016 Rhinohawk Team. All rights reserved.
  * @author Sam Winkelsein	<sjwinkels@gmail.com>
  *
  * Controller for boosted multirotors.
  * A boosted multirotor is a multirotor that has one or more
  * explicit motors for propusion in a single direction.
  * The controller takes in a setpoint named "booster setpoint". this is generated
  * from mc_pos_control and publish as an orb message. This app computes value based
  * on the booster and uses PID control to curve the trottle of the booster motor.
  * the value is the published to an actuator that is linked to a simple mixer linked
  * to the desired main output. This program will launch as it's own task.
  **********************************************************/

#include <px4_config.h>
#include <px4_defines.h>
#include <px4_tasks.h>
#include <px4_posix.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>
#include <poll.h>
#include <drivers/drv_hrt.h>
#include <arch/board/board.h>
#include <uORB/uORB.h>
#include <uORB/topics/actuator_controls.h> /**< actuator orb channels for publishing */
#include <uORB/topics/actuator_armed.h>    /**<  actuator arming status orb message */
#include <uORB/topics/parameter_update.h> /**<  parameter update for any defined parameters. */
#include <uORB/topics/booster_setpoint.h>  /**< booster setpoint orb message */
#include <systemlib/param/param.h>         /**< param generation. */

extern "C" __EXPORT int mc_booster_control_main(int argc, char *argv[]);

class MulticoptorBoosterControl {
public:
  MulticoptorBoosterControl(); // constructor "i dont think we need to pass anything to it"
  ~MulticoptorBoosterControl(); // deconstructor

  int start();

private:
    bool	_task_should_exit;		/**< if true, task_main() should exit */
    void poll_subscriptions();  //poll all active subscriptions
    void publish();     //publish value to actuator based on booster calcuation.
    void task_main();
    struct booster_setpoint_s   _booster_sp;  /**<  struct for booster setpoint generated by uorb. */
    struct actuator_controls_s  _actuators;   /**<  struct for actuator setpoint generated by uorb. */
    struct actuator_armed_s  _arming;
    int _booster_setpoint_sub;
    int _actuators_0_sub;
    int _actuator_armed_sub;
    orb_advert_t   _actuators_0_pub;  //orb advertiser for actuator publishing
    orb_id_t       _actuators_id;     //orb Id for actuator publishing

    struct {
      float booster_scale;     // booster scale parameter
    } _params;
};
namespace mc_booster_control{
  MulticoptorBoosterControl * g_control;
}


MulticoptorBoosterControl::MulticoptorBoosterControl():

_task_should_exit(false),
_control_task(-1),

/* subsctriptions */
_booster_setpoint_sub(-1),
_actuators_0_sub(-1),
_actuator_armed_sub(-1),

/*publications */
_actuators_0_pub(nullptr),
{
  memset(&_booster_sp, 0, sizeof(_booster_sp));
  memset(&_actuators, 0, sizeof(_actuators));
}

MulticoptorBoosterControl::~MulticoptorBoosterControl()
{

    if (_control_task != -1) {
  		/* task wakes up every 100ms or so at the longest */
  		_task_should_exit = true;

  		/* wait for a second for the task to quit at our request */
  		unsigned i = 0;

  		do {
  			/* wait 20ms */
  			usleep(20000);

  			/* if we have given up, kill it */
  			if (++i > 50) {
  				px4_task_delete(_control_task);
  				break;
  			}
  		} while (_control_task != -1);
  	}
    mc_booster_control::g_control = nullptr;
  }


void
MulticoptorBoosterControl::poll_subscriptions()
{
  bool updated;
    orb_check(_booster_setpoint_sub, &updated);  /**< check if booster has been updated */

    if(updated){
    	orb_copy(ORB_ID(booster_setpoint), _booster_setpoint_sub, &_booster_sp); //copy new values to _booster_sp
    }
    orb_check(_actuator_armed_sub, &updated);
    if(updated){
    	orb_copy(ORB_ID(actuator_armed), _actuator_armed_sub, &_arming);    //copy new values tp actuator_armed
    }
    orb_check(_actuators_0_sub, &updated);
    if(updated){
      orb_copy(ORB_ID(actuator_controls), _actuators_0_sub, &_actuators);    //copy new values tp actuator_armed
    }


}
void
MulticoptorBoosterControl::publish()
{
      if(_actuators_0_pub != nullptr){
         orb_publish(_actuators_id, _actuators_0_pub, &_actuators);
      }
      else{
      _actuators_id = ORB_ID(actuator_controls);
      _actuators_0_pub = orb_advertise(_actuators_id, &_actuators);
      }
}
void
MulticoptorBoosterControl::task_main(){
  _booster_setpoint_sub = orb_subscribe(ORB_ID(booster_setpoint));
  _actuators_0_sub = orb_subscribe(ORB_ID(actuator_controls));
  _actuator_armed_sub = orb_subscribe(ORB_ID(actuator_armed));

  _booster_sp.booster = 0.0f;
  _arming.armed = false;
  while(!_task_should_exit){
    poll_subscriptions();
    if(_booster_sp.boosted){
    if(_arming.armed){
       _actuators.control[4] = _booster_sp.booster;

    }
    else{
      _actuators.control[4] = 0.0f;
    }
    publish();
  }
  }
  _control_task = -1;
	return;
}

int
MulticoptorBoosterControl::start()
{
     ASSERT(_control_task == -1);

     _control_task = px4_task_spawn_cmd("mc_booster_control",
     SCHED_DEFAULT,
     SCHED_PRIORITY_MAX - 5,
     1500,
     (px4_main_t)&MultirotorBoosterControl::task_main_trampoline,
     nullptr);
     if(_control_task < 0) {
       warn("task start failed");
       return -errno;
     }

     return OK;
}

int mc_booster_control_main(int argc, char *argv[]){

    if(argc < 2){
    warnx("usage mc_booster_control {start|stop|status}");
    return 1;
  }
  if (!strcmp(argv[1], "start")) {

    mc_booster_control::g_control:: new MulticoptorBoosterControl;

    if(mc_booster_control::g_control == nullptr){
      warnx("alloc failed");
      }

      if(OK != mc_booster_control::g_control->start()){
        delete mc_booster_control::g_control;
        mc_booster_control::g_control = nullptr;
        warnx("start failed");
        return 1;
      }

    return 0;
   }
   if (!strcmp(argv[1], "stop")) {
 		if (mc_booster_control::g_control == nullptr) {
 			warnx("not running");
 			return 1;
 		}

 		delete mc_booster_control::g_control;
 		mc_booster_control:g_control = nullptr;
 		return 0;
 	}

 	if (!strcmp(argv[1], "status")) {
 		if (mc_booster_control::g_control) {
 			warnx("running");
 			return 0;

 		} else {
 			warnx("not running");
 			return 1;
 		}
 	}
